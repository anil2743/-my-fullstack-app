name: Build and Deploy to EKS
on:
  push:
    branches: [ master ]
env:
  AWS_REGION: ap-south-1
  EKS_CLUSTER_NAME: my-fullstack-cluster
  ECR_REPOSITORY_FRONTEND: my-frontend
  ECR_REPOSITORY_BACKEND: my-backend
  IMAGE_TAG: ${{ github.sha }}
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Set up Java 17
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v1

    - name: Get ECR Frontend URI
      id: ecr-frontend
      run: |
        FRONTEND_IMAGE_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_FRONTEND }} --query "repositories[0].repositoryUri" --output text)
        echo "uri=$FRONTEND_IMAGE_URI" >> $GITHUB_OUTPUT

    - name: Get ECR Backend URI
      id: ecr-backend
      run: |
        BACKEND_IMAGE_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_BACKEND }} --query "repositories[0].repositoryUri" --output text)
        echo "uri=$BACKEND_IMAGE_URI" >> $GITHUB_OUTPUT

    - name: Build and Push Frontend Docker Image
      run: |
        FRONTEND_IMAGE_URI="${{ steps.ecr-frontend.outputs.uri }}"
        cd frontend
        docker build --platform=linux/amd64 -t $FRONTEND_IMAGE_URI:${{ env.IMAGE_TAG }} .
        docker push $FRONTEND_IMAGE_URI:${{ env.IMAGE_TAG }}

    - name: Build Backend JAR
      run: |
        cd backend
        mvn clean package -DskipTests

    - name: Build and Push Backend Docker Image
      run: |
        BACKEND_IMAGE_URI="${{ steps.ecr-backend.outputs.uri }}"
        cd backend
        docker build --platform=linux/amd64 -t $BACKEND_IMAGE_URI:${{ env.IMAGE_TAG }} .
        docker push $BACKEND_IMAGE_URI:${{ env.IMAGE_TAG }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Install Metrics-Server
      run: |
        # Check if Metrics Server is already installed
        if kubectl get deployment metrics-server -n kube-system > /dev/null 2>&1; then
          echo "Metrics Server already installed, upgrading..."
          kubectl delete -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml --ignore-not-found=true
        fi
        
        # Install Metrics Server
        echo "Installing Metrics Server..."
        kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
        
        # Wait for Metrics Server to be ready
        echo "Waiting for Metrics Server to be ready..."
        kubectl wait --namespace kube-system --for=condition=ready pod -l k8s-app=metrics-server --timeout=300s
        
        # Verify Metrics Server is working
        echo "Verifying Metrics Server..."
        kubectl get pods -n kube-system | grep metrics-server
        kubectl top nodes

    - name: Deploy to EKS
      run: |
        # Update the image URIs in the deployment files (update hardcoded account ID if needed)
        sed -i "s|145023139102.dkr.ecr.ap-south-1.amazonaws.com/my-backend:.*|${{ steps.ecr-backend.outputs.uri }}:${{ env.IMAGE_TAG }}|g" k8s/backend-deployment.yaml
        sed -i "s|145023139102.dkr.ecr.ap-south-1.amazonaws.com/my-frontend:.*|${{ steps.ecr-frontend.outputs.uri }}:${{ env.IMAGE_TAG }}|g" k8s/frontend-deployment.yaml
        # Apply the manifests
        kubectl apply -f k8s/backend-deployment.yaml
        kubectl apply -f k8s/backend-service.yaml
        kubectl apply -f k8s/frontend-deployment.yaml
        kubectl apply -f k8s/frontend-service.yaml
        # Apply HPA manifests
        kubectl apply -f k8s/backend-hpa.yaml
        kubectl apply -f k8s/frontend-hpa.yaml

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/backend-deployment
        kubectl rollout status deployment/frontend-deployment

    - name: Verify HPA
      run: |
        # Wait for HPA to be ready
        echo "Waiting for HPA to be ready..."
        sleep 30
        
        # Check HPA status
        echo "HPA Status:"
        kubectl get hpa
        
        # Check resource usage
        echo "Resource Usage:"
        kubectl top pods

    - name: Health check
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Run a curl pod to test services
        kubectl run --rm -i --restart=Never --image=curlimages/curl curl-pod -- sh -c "
          # Test backend health endpoint
          echo 'Testing backend health endpoint...'
          curl -f http://backend-service:8080/api/health || exit 1
          
          # Test frontend
          echo 'Testing frontend...'
          curl -f http://frontend-service || exit 1
          
          # Test API through frontend proxy
          echo 'Testing API through frontend proxy...'
          curl -f http://frontend-service/api/health || exit 1
          
          echo 'All health checks passed!'
        "